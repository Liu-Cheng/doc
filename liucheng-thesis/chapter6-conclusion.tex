\chapter{Conclusion and Future Work} \label{chapter:conclusion}
In this work, we have presented the QuickDough compilation framework for high productivity development of FPGA-based loop accelerators. QuickDough makes use of SCGRA as an overlay architecture to greatly improve the designer's compilation experience. By making best use of the underlying FPGA fabrics, the QuickDough overlay is highly pipelined and is able to work at high clock frequency. Meanwhile it is highly scalable, simple and easy to extend for application-specific customization for the sake of performance and energy efficiency. With the overlay architecture, QuickDough pre-builds a group of representative SCGRA overlay based accelerators as a library and allows the pre-built library to be reused during the compile-debug-edit design iterations. Consequently, the lengthy low-level FPGA loop accelerator implementation process is reduced to a rapid acceleration selection process and a fast operation scheduling process. The compilation time of QuickDough is reduced to seconds, which contributes directly into higher application designers' productivity. At the same time, QuickDough also generates the communication interfaces which allows the users to make use of the resulting FPGA loop accelerators during the high-level application development and forms the HW/SW co-design on a hybrid CPU-FPGA computing system. 

Despite the use of an additional layer of overlay architecture on the target FPGA, the overall application performance remains competitive in many cases. Implementation with higher clock frequency resulting from the highly regular structure of the SCGRA, in combination with an in-house scheduler that can effectively schedule operations to overlap with pipeline latency both contribute to the competitive performance of QuickDough.

Finally, QuickDough also includes an automatic application-specific customization process which tunes the design parameters of the FPGA loop accelerators such as the loop unrolling, loop grouping, SCGRA overlay configurations and so on. By taking advantage of the regularity of the overlay, intensive system customization specific to the given user application can be performed efficiently, resulting in up to \num{5} times performance improvement over solutions without customization at the cost of \num{10} to \num{20} minutes additional tools run time. Overall, the framework is able to generate accelerators that achieve up to \num{10} times speed up over software running on the host processor, resulting in a high design productivity experience for software programmers.

The contributions of this work include the following aspects.
\begin{itemize}

\item By utilizing the SCGRA overlay as an intermediate fabric on top of physical FPGA, an FPGA loop accelerator design framework QuickDough that can rapidly produce loop accelerator is proposed. With pre-built accelerator library, a high-level loop kernel can be compiled to the corresponding FPGA accelerator bitstream in seconds dramatically increasing the number of compile-debug-edit cycle per day. When compared to a hard ARM processor, the performance of the resulting accelerators developed using QuickDough achieves up to 10X speedup.

\item A highly pipelined, flexible and scalable SCGRA overlay template is developed. With this template, the generated loop accelerators with various configurations can work at high frequency and achieve higher performance accordingly. The scalability and flexibility of the overlay template makes it convenient to be adapted to a different application which also helps to automate the accelerator generation. 

\item By taking advantage of the regularity of the SCGRA overlay based loop accelerator, the design parameters of the overlay based accelerators from high-level loop unrolling, on-chip buffer sizing and overlay configuration are automatically customized efficiently achieving optimized performance and energy efficiency of the resulting accelerators. Compared with an exhaustive search, the proposed customization method can be two orders of magnitude faster while achieving similar performance.

\end{itemize}
  
\section{Future Work}
Although this work has demonstrated that the use of an SCGRA overlay is promising to enhance the designers' design productivity and accessibility to software designers compared with conventional FPGA accelerator development, there are still a number of aspects that may further be studied. 

\subsection{High Level Compilation}
QuickDough focuses on producing FPGA loop accelerator targeting a hybrid CPU-FPGA computing system. To serve as a complete automatic HW/SW synthesis framework for software designers, many high-level design options such as the identification of compute kernel to offload to FPGAs are still highly required. In addition, when an application with multiple loop kernels is mapped to the same FPGA device, optimized strategies allowing the loop kernels to share the limited FPGA resource while achieving high performance of the overall application need be explored as well. It can be challenging especially when some of the loop kernels are dependent and some of the loop kernels may be executed in parallel.

On top of the high-level compilation options, compiling the loop kernels to the specified SCGRA overlay is also difficult. In order to compile a high-level loop kernel to an SCGRA overlay, DFG is typically adopted as an intermediate representation (IR). Currently, the generation of DFGs from the loop kernels involves several manual conversion steps to match the user design with the target overlay. It is anticipated that an automated process that is able to analyze the user application and generate the corresponding DFG suitable for the overlay will be developed. Many existing works typically generate the DFGs through well-known compilation framework such as LLVM. However, the compilation framework adopts an IR that is initially developed for processors. It is convenient to map the IR to instructions defined by ISAs of the processors, while it is rather challenging to transform the IRs to DFGs for SCGRA overlay scheduling. An IR that are friendly to CGRA architectures may help to solve this challenge.

Unlike processors which allows separate micro architecture design with the same ISA, SCGRA overlay micro architecture design are difficult to abstract and the modification of the micro architectures are typically exposed to the scheduler. As a result, it is difficult to reuse the same scheduler for different SCGRA overlays, which essentially limits the design space exploration of the SCGRA overlay architecture. A flexible SCGRA overlay abstraction as well as scheduler will be beneficial to the SCGRA overlay based FPGA loop accelerator development. 

\subsection{Heterogeneous SCGRA Overlay}
With a homogeneous SCGRA overlay template, this work has already shown the promising performance and energy efficiency improvement through application-specific SCGRA overlay customization. Heterogeneous SCGRA overlay allows even more intensive customization specifically to an user application is thus beneficial to the overlay performance and energy efficiency. 

Some of the complex operations such as division and square root may be not used as frequently as simple operations in an loop kernel, but they may still be performance bottleneck or have great influence on the overall loop execution time. At the same time, it is not worthwhile to put these complex operations on host processor which may cause considerable communication between the accelerator and host processor. In addition, implementing the complex operations on all the PEs of a homogeneous SCGRA overlay results in a large amount of resource as well as energy consumption. In this case, implementing these complex operations on part of the PEs of an heterogeneous SCGRA overlay will outperform on energy consumption while achieving similar performance, while deciding the PEs that will be optimal to add the complex operations remains a design challenge.

On top of the complex operations, frequent operations with close data dependency may be accumulated as a customized complex operation as well. It brings two-folded benefits to the overall FPGA acceleration system. On the one hand, the customized operation implemented with separate data path typically has shorter latency compared to the group of operations executed on different PEs which are scheduled by the SCGRA overlay scheduler. In addition, a group of operations with close communication scheduled as a unit on a single PE also reduces the communication which is essentially beneficial to the overall performance of the loop kernel. On the other hand, although the additional data paths of the customized operations consume more FPGA resources including LUT, DSPs and FFs, it reduces overlay execution time and thus the requirements of instruction memory which alleviates the resource bottleneck of the SCGRA overlay based FPGA accelerators. However, the design space is extremely large and it is rather challenging to determine the most appropriate customized operation of an application. Moreover, when the customized operations are decided, it is also difficult to automate the customized operation data path generation.

\subsection{SCGRA Computing Model}
QuickDough adopts SCGRA as the overlay architecture and it relies on lock-step computing to exploit the potential parallel operations of the loop kernels, so the data dependency in the loop kernels typically should be known at compilation time. Although some of the high-level code such as simple branches in the loop kernels can be transformed to code with deterministic data dependency through if-conversion, many high-level code such as \texttt{while} loop with data dependent loop count can't be transformed to DFGs and executed on the SCGRA overlay, which greatly limits the adoption of the SCGRA overlay for loop acceleration. One possible solution is to add control support to PEs of the SCGRA overlay so that each PE can support branch and loop. While adding control support is not a barrier, the basis of lock-step computing that helps to explore the data level parallelism on the SCGRA overlay is no longer existed. To that end, instead of scheduling operations in the same loop iteration to the PEs, multiple loop iterations can be mapped to the same PE of the SCGRA overlay. Basically each PE in the overlay executes sequentially while the overlay executes in parallel globally to explore the loop-level parallelism. The locally sequential execution and globally execution model can be adopted to allow the SCGRA overlays to handle loop kernels with more complex control logic in the loop body. However, when the loop iterations are dependent, both the communication between the PEs and the loop scheduling will be challenging.
