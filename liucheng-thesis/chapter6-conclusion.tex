\chapter{Conclusion and Future Work} \label{chapter:conclusion}
In this work, we have presented the QuickDough compilation framework for high productivity development of FPGA-based loop accelerators. QuickDough makes use of SCGRA as an overlay architecture to greatly improve the designer's compilation experience. By making best use of the underlying FPGA fabrics, the QuickDough overlay is highly pipelined and is able to work at high clock frequency. Meanwhile it is highly scalable, simple and easy to extend for application-specific customization for the sake of performance and energy efficiency. With the overlay architecture, QuickDough pre-builds a group of representative SCGRA overlay based accelerators as a library and allows the pre-built library to be reused during the compile-debug-edit design iterations. Consequently, the lengthy low-level FPGA loop accelerator implementation process is reduced to a rapid acceleration selection process and a fast operation scheduling process. The compilation time of QuickDough is reduced to seconds, which contributes directly into higher application designers' productivity. At the same time, QuickDough also generates the communication interfaces which allow the users to make use of the resulting FPGA loop accelerators during the high-level application development and develop a complete HW/SW co-design on a hybrid CPU-FPGA computing system. 

Despite the use of an additional layer of overlay architecture on the target FPGA, the overall application performance remains competitive in many cases. Implementation with higher clock frequency resulting from the highly pipelined SCGRA overlay, in combination with an in-house scheduler that can effectively schedule operations to hide the pipeline latency contributes to the competitive performance of the resulting accelerators generated using QuickDough.

Finally, QuickDough also includes an automatic application-specific customization process which tunes the design parameters of the FPGA loop accelerators such as the loop unrolling, loop grouping, SCGRA overlay configurations and so on. By taking advantage of the regularity of the overlay, intensive system customization specific to the given user application can be performed efficiently, resulting in up to \num{5} times performance improvement over solutions without customization at the cost of \num{10} to \num{20} minutes additional tools run time. Overall, the framework is able to generate accelerators that achieve up to \num{10} times speed up over software running on the host processor, resulting in a high design productivity experience for software programmers.
  
\section{Future Work}
Although this work has demonstrated that the use of an SCGRA overlay is promising to enhance the designers' design productivity and accessibility to software designers compared to conventional FPGA accelerator development, there are still a number of aspects that may further be studied. 

\subsection{High Level Compilation}
QuickDough focuses on producing FPGA loop accelerator targeting a hybrid CPU-FPGA computing system. To serve as a complete automatic HW/SW co-synthesis framework for software designers, many high-level design options such as the identification of compute kernels that are most appropriate to offload to FPGAs are still highly required. In addition, when multiple loop kernels from a single application are mapped to the same FPGA device with limited hardware resources, optimized strategies allowing the loop kernels to share the limited FPGA resource while achieving optimized performance of the overall application need to be explored as well. It can be challenging especially when some of the loop kernels are dependent while some of the loop kernels may be executed in parallel.

On top of the high-level compilation options, compiling the loop kernels to the specified SCGRA overlay is also difficult. In order to compile a high-level loop kernel to an SCGRA overlay, DFG is typically adopted as an intermediate representation (IR). Currently, the generation of DFGs from the loop kernels involves several manual conversion steps to match the user design with the target overlay. It is anticipated that an automated process that is able to analyze the user application and generate the corresponding DFG suitable for the overlay will be developed. Many existing works typically generate the DFGs through well-known compilation framework such as LLVM. However, the compilation framework adopts an IR that is initially developed for processors. It is convenient to map the IR to instructions defined by ISAs of the processors, while it is rather challenging to transform the IRs to DFGs for SCGRA overlay scheduling. An IR that are friendly to CGRA architectures may help to solve this challenge.

Unlike processors which typically have ISAs to separate the micro architecture implementations and high-level application compilation, the SCGRA overlay typically have the implementation details exposed to the operation scheduler. As a result, it is difficult to reuse the same scheduler for SCGRA overlays with different design options such as the pipeline depth, which essentially limits the design space exploration of the SCGRA overlay based FPGA loop accelerator design. A flexible SCGRA overlay abstraction that separates the overlay implementation details and high level compilation may solve this problem. 

QuickDough adopts an SCGRA as the overlay architecture and it relies on lock-step computing to exploit the potential parallel operations of the loop kernels, so the data dependency in the loop kernels typically should be known at compilation time. Although some of the high-level code such as simple branches in the loop kernels can be transformed to code with deterministic data dependency through if-conversion, many high-level code such as \texttt{while} loop with data dependent loop count can't be transformed to DFGs and executed on the SCGRA overlay, which greatly limits the adoption of the SCGRA overlay for loop acceleration. One possible solution is to add control support to PEs of the SCGRA overlay so that each PE can support branch and loop. While adding control support to the SCGRA overlay is not a barrier, the basis of lock-step computing that helps to explore the data level parallelism on the SCGRA overlay is no longer existed. To that end, instead of scheduling operations in the same loop iteration to the PEs, multiple loop iterations can be mapped to the same PE of the SCGRA overlay. Basically each PE in the overlay executes sequentially while the overlay executes in parallel globally to explore the loop-level parallelism. The locally sequential execution and globally parallel execution model can be adopted to allow the SCGRA overlays to handle loop kernels with more complex control logic in the loop body. However, when the loop iterations are dependent, both the communication between the PEs and the loop scheduling will be challenging.

\subsection{Heterogeneous SCGRA Overlay}
With a homogeneous SCGRA overlay template, this work has already shown the promising performance and energy efficiency improvement through application-specific SCGRA overlay customization. Heterogeneous SCGRA overlay allows even more intensive customization specifically to an user application is thus beneficial to the overlay performance and energy efficiency. 

Some of the complex operations such as division and square root may not appear as frequently as simple operations in an loop kernel, but they may still be performance bottleneck or have great influence on the overall loop execution time. At the same time, it is not worthwhile to put these complex operations on host processor which may cause considerable communication between the accelerator and host processor. In addition, implementing the complex operations on all the PEs of a homogeneous SCGRA overlay results in a large amount of resource as well as energy consumption. In this case, implementing these complex operations on part of the PEs of an heterogeneous SCGRA overlay will outperform on energy consumption while achieving similar performance, while the increased design space makes the DSE even more challenging.

On top of the complex operations, frequent operations with close data dependency may be accumulated as a customized complex operation as well. It brings two-folded benefits to the overall FPGA acceleration system. On the one hand, the customized operation implemented with separate data path typically has shorter latency compared to the group of operations executed on different PEs scheduled by the SCGRA overlay scheduler. In addition, a group of operations with close communication scheduled as a unit on a single PE also reduces the communication which is essentially beneficial to the overall performance of the loop kernel. On the other hand, although the additional data paths of the customized operations consume more FPGA resources including LUT, DSPs and FFs, it reduces overlay execution time and thus the requirements of instruction memory which further alleviates the resource bottleneck of the SCGRA overlay based FPGA accelerators. However, the design space is extremely large and it is rather challenging to determine the optimized customized operations of an application. Moreover, when the customized operations are decided, it is also difficult to automate the customized operation data path generation.
