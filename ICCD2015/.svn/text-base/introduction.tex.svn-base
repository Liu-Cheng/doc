\section{Introduction}\label{sec:introduction}
Recent years have witnessed a tremendous growth in the use of accelerators in computer systems to
improve the systems' performance and power-efficiency. Among these accelerators, GPUs and
the Xeon Phi accelerators have stood out as two of the most popular choices in spite of their
relatively short history as accelerators --- 5 of the top 10 systems on the top500 list take 
advantage of them. On the other hand, despite the long and successful track record of FPGA
accelerators \cite{bing2014FPGA}, the use of FPGA accelerators in main-stream systems remains
limited and has yet to receive widespread adoption beyond highly skilled hardware engineers.

We argue that there are 3 major challenges faced by software developers when using FPGAs as
accelerators: (1) the unfamiliar hardware development methodology with low-level hardware
description languages; (2) the lack of hardware-software support during run-time and compile-time;
and (3) the lack of efficient implementation and debugging facilities.

To address challenge 1, recent advances in high-level synthesis tools have significantly raised the
abstraction level for FPGA design entry, allowing users to effectively express hardware designs
using familiar software languages such as C/C++, Java, Python and Scala.
At the same time, to address challenge 2, researchers have also explored various facilities to
support mixed hardware-software designs in a unified language \cite{openCL,SDAccel} and run-time
environment \cite{SoTECS:2008,Lubbers:2009,Ismail:2011}. Challenge 3, however, remains a major
productivity hurdle to most software developers. Unlike compiling software programs, implementing
a hardware design on to an FPGA using standard hardware design tools can take upward of days with
some of the largest designs. This disproportionally long run time greatly limits the number of
debug-edit-implement-cycle per day possible and hinders the designer's productivity.

The focus of this work is therefore to address challenge 3. In particular, we are interested in
significantly improving the speed of generating hardware accelerators on FPGAs for compute intensive
loops expressed in high-level languages, while maintaining a competitive overall performance for the
resulting system.

To that end, we have developed QuickDough, a design framework that rapidly generates loop
accelerators and their associated software-hardware data I/O facilities on FPGAs.
By using a soft coarse-grain reconfigurable array (SCGRA) \emph{overlay} as an intermediate
architecture implemented on top of the physical FPGAs, QuickDough partitions the
complex accelerator development flow into two paths.
Along the rapid and common path, QuickDough generates loop accelerators by selecting an overlay
configuration from a library of partially implemented FPGA bitstream, schedules the compute
operations from the user-provided loop onto the overlay, and finally updates the bitstream
configuring the target FPGA. On the other hand, QuickDough can also update the overlay bitstream
library upon user request. This process is considerably slower as a number of accelerators may need to
be implemented and added to the library. In these cases, QuickDough helps to expedite the
library update process by providing a minimum representative set of accelerator configurations
to be implemented and added to the library. Moreover, to ensure the system accessible to application
developers, the pre-built accelerator library will be automatically generated using a template based
system and implemented accordingly.

Experiments show that despite the use of an overlay, the accelerators generated by QuickDough 
has promising performance speedup over the software executed on a hard ARM processor, yet 
the accelerator generation completes in seconds achieving near-software compilation speed 
and enhancing software designers' productivity in designing, developing and debugging 
their applications with accelerators. 

In next section, we will elaborate on the FPGA loop accelerator design framework -- QuickDough. Then
we will present the experimental results in \secref{sec:experiments}. Finally, we will compare
QuickDough with related works in \secref{sec:relatedwork} and conclude in \secref{sec:conclusions}.


