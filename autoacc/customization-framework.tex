\section{SCGRA Overlay Based FPGA Accelerator Customization} \label{sec:customization-framework}
Application-specific customization provides unique opportunity to improve 
the power-performance of the resulting accelerators. However, 
taking the system as a black box and exhaustively searching all the 
possible configurations can be inefficient and slow, which will 
result in low design productivity. In this work, by taking advantage 
of the regularity of the SCGRA overlay based FPGA accelerator, we 
can reduce the complex customization problem to a small DSE together with 
a simple search problem, and near optimal application-specific 
nested loop acceleration can be achieved rapidly.

\subsection{Customization Framework}
\figref{fig:customization-framework} illustrates the details 
of the customization framework. It can be roughly divided into two 
parts. In the first part, a sub DSE targeting loop execution time 
is performed and the feasible design space can be acquired. Since loop 
execution time is determined by the operation scheduling 
which merely depends on the loop unrolling factor and SCGRA size, the 
sub DSE is much simpler compared to the overall 
system DSE. 

In the second part, each configuration 
in the feasible design space will be evaluated. Instead of using simulation 
based methods, analytical models are employed to estimate the accelerator 
metrics such as performance, overhead, energy consumption etc.. 
Because of the regularity of the SCGRA overlay, these models are 
relatively straightforward yet effective. 
Even though the feasible design space is still large, it is fast to evaluate 
all the configurations in the feasible design space. After the evaluation process, 
customization for various design goals becomes trivial and the customized 
design parameters can be obtained immediately.

\begin{figure}[t]
\center{\includegraphics[width=0.85\linewidth]{customization-framework}}
\caption{System customization framework.}
\label{fig:customization-framework}
\end{figure}

\subsection{Customization Problem Formulation}
In this section, we will formalize the customization problem 
of the nested loop acceleration on an SCGRA overlay based FPGA accelerator. 
Various design goals including performance, energy consumption and 
energy delay product (EDP) can be used while energy consumption is taken 
as an example here.

\begin{table}[tb]
    \begin{threeparttable}
\small
\centering
\caption{Design Parameters of Nested Loop Acceleration\label{tab:parameter-list}}{
\begin{tabular}{l|l|l}
\hline
\multicolumn{2}{l|}{Design Parameters} & Denotation \\ \hline
\multirow{2}{*}{\tabincell{l}{Nested Loop \\ Compilation}} & Loop Unrolling Factor & $\bm{u}=(u_0,u_1, ...)$  \\ \cline{2-3} 
                                                           & Grouping Factor & $\bm{g}=(g_0, g_1, ...)$ \\ \hline
\multirow{11}{*}{\tabincell{l}{Overlay \\ Configuration}}  & SCGRA Topology  & NaN, 2D Torus \\ \cline{2-3} 
                                                          & SCGRA Size  & $r\times c$ \\ \cline{2-3}
                                                          & Instruction Mem & $imD \times imW$ \\ \cline{2-3}
                                                          & Data Mem & $dmD \times dmW$ \\ \cline{2-3}
                                                          & Input Buffer & $ibD \times ibW$ \\ \cline{2-3}
                                                          & Output Buffer & $obD \times obW$ \\ \cline{2-3}
                                                          & Input Address Buffer & $iabD \times iabW$ \\ \cline{2-3}
                                                          & Output Address Buffer & $oabD \times oabW$ \\ \cline{2-3}
                                                          & Operation Set & NaN, fixed \\ \cline{2-3}
                                                          & Implementation Frequency & $f$, fixed \\ \hline
                                                          & Pipeline Depth & NaN, fixed \\ \hline
\end{tabular}
\begin{tablenotes}
    \small
\item NaN means there is no denotation for that parameter.
\end{tablenotes}
}
\end{threeparttable}
\end{table}

Suppose $\bm{\Psi}$ represents the overall nested loop acceleration design 
space. $\bm{C} \in \bm{\Psi}$ represents a possible configuration in 
the design space and it includes a number of design parameters as  
listed in \tabref{tab:parameter-list}. Assume that the loop to be accelerated 
has $n$ nested levels and loop count can be denoted as $l=(l_1, l_2, ..., l_n)$.
$R=(R_1, R_2, R_3, R_4)$ stands for the FPGA resource (i.e. BRAM, DSP, LUT and FF) 
that are available on a target FPGA and $Overhead(\bm{C}, i)$ denotes the 
four different types of FPGA resource overhead. $In(\bm{g})$ and $Out(\bm{g})$ 
stand for the amount of input and output of a group. Similarly, $In(\bm{u})$ 
and $Out(\bm{u})$ stand for the amount of input and output of a DFG. 
$DFGCompuTime(\bm{C})$ represents the number of cycles needed to 
complete the DFG computation. $\alpha_i$ and $\beta_i$ are constant 
coefficients depending on target platform where $i=(1,2,...)$. With these denotations, 
the customization problem targeting minimum energy consumption can be formulated 
as follows:

Minimize 
\begin{equation} \label{eq:energy}
    Energy(\bm{C})=Power(\bm{C}) \times (\frac{RunTime(\bm{C})}{f})
\end{equation}
subject to
\begin{equation} \label{eq:constraints}
    \begin{split}
        &Overhead(\bm{C}, i) \leq R_i, i=1,2,3,4 \\
        &In(g) \leq ibD \\
        &Out(g) \leq obD \\
        &DFGCompuTime(\bm{C}) \leq imD \\
        &\displaystyle \prod_{i=1}^{n} \frac{g_i}{u_i} \times In(u) \leq iabD \\
        &\displaystyle \prod_{i=1}^{n} \frac{g_i}{u_i} \times Out(u) \leq oabD
    \end{split}
\end{equation}

$RunTime(\bm{C})$ represents the number of cycles needed to compute the loop on 
the CPU-FPGA system. It consists of both the time consumed for computing on FPGA and 
communication between FPGA and host CPU, and it can be calculated by \eqref{eq:runtime}.

\begin{equation} \label{eq:runtime}
    RunTime(\bm{C})=CompuTime(\bm{C})+CommuTime(\bm{C})
\end{equation}

Since the unrolled part of the loop will be translated to 
DFG and then scheduled to the SCGRA overlay. Thus the DFG computation time 
is essentially a function of $\mathbf{u}$, $r$ and $c$ and it can also be 
denoted by $DFGCompuTime(\mathbf{u},r,c)$.
The nested loop is computed by repeating the same DFG execution, and the 
nested loop computation can be calculated by \eqref{eq:loopexetime}.
\begin{equation} \label{eq:loopexetime}
    CompuTime(\bm{C})=\displaystyle \prod_{i=1}^{n} \frac{l_i}{u_i} \times DFGCompuTime(\mathbf{u},r,c)
\end{equation}

DMA is typically used for the bulk data transmission. Communication cost per 
data can be modeled with a piecewise linear function and thus DMA latency can be 
calculated by \eqref{eq:DMA}.

\begin{equation} \label{eq:DMA}
    DMA(x)=%
    \begin{cases}
        (\alpha_1\times x + \beta_1) \times x &: (x \leq T_0) \\
        (\alpha_5\times x + \beta_5) \times x &: (T_0 < x \leq T_1) \\
        \alpha_6\times x &: (x > T_1)
    \end{cases}
\end{equation}

where $x$ represents the amount of DMA transmission and $T_0, T_1$ stand for 
the turning points of the piecewise function. The communication time of the 
whole nested loop can be calculated by \eqref{eq:commu}.
\begin{equation} \label{eq:commu}
    CommuTime(\bm{C})=\displaystyle \prod_{i=1}^{n} \frac{l_i}{g_i} \times 
    (DMA(In(\mathbf{g}))+DMA(Out(\mathbf{g})))
\end{equation}

Power consumption of the FPGA accelerator is consisted of 
BRAM block power, clock power, signal power, DSP power and so on. 
According to our experiments, BRAM block power presents quite 
good linearity to the amount of 
the BRAM overhead and can be calculated with \eqref{eq:brampower}. 
The rest part of the hardware resource mainly changes with the SCGRA size, 
so the power consumption can be roughly modeled with a linear 
equation of SCGRA size. Therefore, the power consumption 
of the accelerator can be modeled by \eqref{eq:totalpower}.
\begin{equation} \label{eq:brampower}
    \begin{split}
        Power\_BRAM(\bm{C})=&\alpha_7 \times r \times c \\ 
        &\times Overhead(\bm{C}, 1)
    \end{split}
\end{equation}
\begin{equation} \label{eq:totalpower}
    Power(\bm{C})=Power\_BRAM(\bm{C})+\alpha_8 \times r \times c + \beta_6
\end{equation}

Hardware overhead on FPGA mainly includes DSP, LUT, FF and 
BRAM (block RAM). LUT, FF and DSP overhead can be roughly estimated 
with a linear function of SCGRA size and can be calculated using \eqref{eq:dsplutff}. 
BRAM overhead which is usually the overhead bottleneck for SCGRA overlay based 
FPGA accelerator design can be calculated by \eqref{eq:bramoverhead}
\begin{equation} \label{eq:dsplutff}
    Overhead(\bm{C}, i)=\alpha_i \times r \times c + \beta_i, (i=2,3,4)
\end{equation}
\begin{equation} \label{eq:bramoverhead}
    \begin{split}
        Overhead(\bm{C}, 1)=&r \times c \times \\ 
                               &(imD \times imW + dmD \times dmW) + \\
                               &(ibD \times ibW + obD \times obW) + \\
                               &(iabD \times iabW + oabD \times oabW) 
    \end{split}
\end{equation}

\subsection{Proposed Customization Method}
According to the formulated customization problem, it can be found that 
almost all the design parameters can be estimated with analytical models except 
the operation scheduling process as shown in $DFGCompuTime(\bm{u},r,c)$.Fortunately 
it merely depends on unrolling factor and the SCGRA overlay size. Therefore, 
we can separate the scheduling from the customization problem and 
perform a sub DSE to shrink the large design space to a smaller feasible 
design space. Then we can take advantages of the analytical models developed 
in previous section to search for the optimized design parameter for the entire 
system customization.

The feasible design space is defined as follows and it is simply related 
with the operation scheduling. Suppose $\Phi$ denotes the feasible 
design space. $\epsilon$ indicates the performance benefit percentage 
acquired by the increase of loop unrolling or SCGRA size. It is a user defined 
threshold and must be small enough to prune the configurations that are 
inappropriate. The configurations in $\Phi$ must satisfy \eqref{eq:cond1} 
and \eqref{eq:cond2}.
\begin{equation} \label{eq:cond1}
    \begin{split}
        &\forall \bm{C}=(...,\bm{u},r,c,...)\in \Phi, \bm{C'}=(...,\bm{u'},r',c',...) \in \Phi,\\ 
        & (r+1==r' \text{ and } c==c') \text{ or } (r==r' \text{ and } c+1==c'): \\ 
        &\frac{CompuTime(\bm{C})-CompuTime(\bm{C'})}{CompuTime(\bm{C})} > \epsilon \\
    \end{split}
\end{equation}

\begin{equation} \label{eq:cond2}
    \begin{split}
        &\forall \bm{C}=(...,\bm{u},r,c,...) \in \Phi, \bm{C'}=(...,\bm{u'},r,c,...) \in \Phi,\\ 
        &\bm{u} \text{ and } \bm{u'} \text{ are consecutive unrolling factors}: \\
        &\frac{CompuTime(\bm{C})-CompuTime(\bm{C'})}{CompuTime(\bm{C})} > \epsilon
    \end{split}
\end{equation}

Each configuration $\bm{C} \in \Phi$ must be scheduled and 
thus the computation time of the loop kernel, minimum instruction 
memory depth and data buffer depth are recorded. Then we can further evaluate 
energy consumption of each feasible configuration using the models built in 
previous section and acquire the optimized configuration.

In order to achieve the desired customization, we must make sure the 
feasible design space acquired from the scheduling problem can always 
cover the configuration that produces optimal customization. Here we 
will present a brief proof that the design space acquired through the 
proposed sub design space exploration can cover the configuration that 
leads to optimized customization.

$\forall \bm{C'} \notin \Phi$, there must be a configuration $\bm{C}$ that fails 
\eqref{eq:cond1} or \eqref{eq:cond2}. Suppose $\bm{C'}=(...,\bm{u},r+1,c,...)$ 
and $\bm{C}=(...,\bm{u},r,c,)$. Thus we can conclude that 
\begin{equation}
    CompuTime(\bm{C'}) \geq (1-\epsilon) \times CompuTime(\bm{C})
\end{equation}

Since $\epsilon$ can be small and unrolling factor is not changed, $DFGCompuTime(\bm{C'})$ 
roughly equals to $DFGCompuTime(\bm{C})$ and therefore the instruction memory depth 
will not change. However, the increase of row size of the SCGRA overlay will result in 
significant overhead of BRAM and power consumption. Thus $Power(\bm{C'}) 
\geq Power(\bm{C})$. In addition, it will reduce the BRAM budget 
for on-chip buffer, which means 
$CommuTime(\bm{C'}) \geq CommuTime(\bm{C})$. According to \eqref{eq:energy} 
and \eqref{eq:runtime}, it is clear that $Energy(\bm{C'}) \geq Energy(\bm{C})$ and 
any configuration that is pruned during the sub DSE will not be an optimized 
configuration. Similarly, we can also draw the same conclusion when a different 
occasion in \eqref{eq:cond1} and \eqref{eq:cond2} appears.

In addition, a series of experiments on Zedboard \cite{zedboard} as 
shown in \figref{fig:observation} demonstrate that SCGRA size and 
unrolling factor present a clear monotonic influence on the 
loop compute time. The performance benefit of loop unrolling and 
increase of SCGRA size drops gradually and thus we can conclude \eqref{eq:observation}.
\begin{equation} \label{eq:observation}
    \begin{split}
        CompuTime&(\bm{C_1})-CompuTime(\bm{C_2}) > \\
                 &CompuTime(\bm{C_2})-CompuTime(\bm{C_3})
    \end{split}
\end{equation}
where $\bm{C_1}=(...,x1,...)$, $\bm{C_2}=(...,x2,...)$, $\bm{C_3}=(...,x3,...)$ and
$x1$, $x2$, $x3$ are three increasingly consecutive configurations of loop unrolling 
factor or row or column of the SCGRA overlay.

In other words, if $\bm{C_1}$ fails to be a feasible configuration, we can be 
sure that $\bm{C_2}$ and $\bm{C_3}$ will fail as well. With this observation, 
we can further simplify the sub design space exploration. The simplified sub DSE will be 
detailed in the following section.

\begin{figure}[H]
    \subfloat[\label{fig:scgrasize-perf}]{%
      \includegraphics[width=0.235\textwidth]{scgrasize-perf}
    }
    %\hfill
    \subfloat[\label{fig:unrolling-perf}]{%
      \includegraphics[width=0.22\textwidth]{unrolling-perf}
    }
    \caption{The design parameters typically have monotonic influence on the
        loop computation time and the computation time benefit degrades with 
        the increase of the design parameter. (a) SCGRA Size, (b) Unrolling Factor}
    \label{fig:observation}
  \end{figure}


\subsection{Sub Design Space Exploration}
To acquire the feasible design space, we perform a delicate sub DSE 
targeting nested loop computation time. It involves only the SCGRA overlay 
size and the loop unrolling factor. Therefore, the sub DSE is much simpler 
compared to the overall customization problem. Based on the 
observation in \figref{fig:observation}, a branch and bound algorithm 
is used and the algorithm is detailed in \algref{alg:revenuealg}. 

\begin{algorithm}[h]
\caption{Sub Design Space Exploration.}
\label{alg:revenuealg}
\begin{algorithmic}
\PROCEDURE{}
\STATE Initialize $r=2, c=1, \bm{u}=(1,1,...)$, feasible design space $\Phi=\emptyset$,
$\bm{C}=(...,r,c,\bm{u},...)$, maximum SCGRA overlay $r_{Max}\times c_{Max}$.
\WHILE {$r<r_{Max}$} 
\WHILE {$c<c_{Max}$}
\WHILE {$\bm{u}$ is not fully unrolled}
\STATE Generate DFG with $\bm{u}$
\STATE DFG Scheduling with configuration $\bm{C}$
\STATE Estimate performance $CompuTime(\bm{C})$
\STATE Get neighbor $\bm{C'} \in \Phi$ with smaller loop unrolling
\IF {$\bm{C'}$ exists and $Revenue(\bm{C}, \bm{C'}) \leq \epsilon$}
\STATE Break
\ELSE 
\STATE Add $\bm{C}$ to $\Phi$
\ENDIF
\STATE update $\bm{u}$ with larger neighbor unrolling factor
\ENDWHILE
\STATE Get neighbor $\bm{C''} \in \Phi$ with smaller column size
\IF {$\bm{C''}$ exists and $Revenue(\bm{C}, \bm{C''}) \leq \epsilon$}
\STATE Break
\ENDIF
\STATE $c=c+1$
\ENDWHILE
\STATE Get neighbor $\bm{C'''} \in \Phi$ with smaller row size
\IF {$\bm{C'''}$ exists and $Revenue(\bm{C}, \bm{C'''}) \leq \epsilon$}
\STATE Break
\ENDIF
\STATE $r=r+1$
\ENDWHILE
\ENDPROCEDURE
\STATE
\PROCEDURE {$Revenue(\bm{C}, \bm{C'})$}
\STATE return $\frac{CompuTime(\bm{C'})-CompuTime(\bm{C})}{CompuTime(\bm{C'})}$ 
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}

The basic idea of the algorithm is to gradually explore the SCGRA row size, column size 
and loop unrolling factor. Whenever a configuration fails the sub DSE condition, 
all the configurations that are larger on the analyzed design parameter will be pruned so 
that we can reduce the total number of configurations to be evaluated.
