\section{Related Work}\label{sec:relatedwork}
FPGA design productivity remains a major obstacle that hinders the use of FPGA as computing devices from widespread adoption. Researchers have tried to approach the problem both by increasing the abstraction level of the design entry and reducing the compilation time.

In the first case, decades of research in FPGA high-level synthesis have already demonstrated their indispensible role in promoting FPGA design productivity \cite{cong2011high}. Numerous design languages and environments \cite{cardoso2010compiling} have been developed to allow designers to focus on high-level functionality instead of low-level implementation details. While the high-level abstraction helps to express the desired functionality, the low-level compilation time spent in synthesis, mapping, placing and routing is equally crucial to the design productivity. Researchers have approached the problem from many angles including the use of pre-compiled hard macros \cite{lavin2011}, partial reconfiguration and modular design flow \cite{Frangieh2010}. 

On top of the above approaches, overlay, which can be parametric HDL Model, pre-synthesized or pre-implemented coarse-grained reconfigurable circuits over the fine-grained FPGA devices, promises both to raise the abstraction level and reduce the compilation time. Recent years have seen a number of overlays \cite{Lebedev2010,kissler2006dynamically,unnikrishnan2009application,Yiannacouras2009FPS,Guy2012VENICE,Jeffrey2011potential} with granularities ranging from multi-processors to highly configurable logic arrays. 

Soft processors, which allow customization for target applications or application domains, have already been demonstrated to be efficient overlays on FPGA. The authors in \cite{Yiannacouras2007Exploration} \cite{microblaze} and \cite{nios} mainly have micro-architecture parameters such as pipeline depth configurable, while the authors in \cite{grad2009woolcano} allow instruction set architecture (ISA) customizable. The authors in \cite{Kock2013CI} developed a fine-grain virtual FPGA overlay specially for custom instruction extension, which makes the custom instruction implementation portable and fast. The authors in \cite{Lebedev2010} proposed a many-core overlay with customizable data path. This overlay can be used to explore both the coarse-grain multi-thread parallelism and data-flow style fine-grain threading parallelism. The authors in \cite{unnikrishnan2009application} presented a multi-processor overlay with both micro-architecture and interconnection customizable. The authors in \cite{Guy2012VENICE} and \cite {Yiannacouras2009FPS} took reconfigurable vector processors as the FPGA overlay to cover domain specific applications. The authors in \cite{Jeffrey2011potential} presented a GPU-Like overlay for portability. It can be used to explore both the data-level parallelism and thread level parallelism. These processor level overlays achieve the customization from diverse angles, but essentially they tend to expose a processor to the user. Thus the application development is quite close to a conventional software design, while the penalty is the hardware overhead and implementation frequency compared to a customized hardware design.    

Another group of FPGA overlays are virtual FPGAs \cite{zuma2013carl} \cite{Grant2011Malibu} \cite{Coole2010Intermediate}. They are built on top of the off-the-shelf FPGA devices and typically have coarser granularity. The virtual FPGA overlays are beneficial to improving the design productivity and portability, though they do result in moderate hardware overhead and timing degradation.   

Between the processor level overlays and virtual FPGA level overlays, CGRA overlays on FPGA have unique advantages of compromising hardware implementation and performance especially for compute intensive applications as demonstrated by numerous ASIC CGRAs \cite{tessier2001reconfigurable} \cite{compton2002reconfigurable}. CGRAs on FPGA and ASIC have many similarities in terms of the scheduling algorithm and array structure, however, they have quite different trade-off on configuration flexibility, overhead and performance. Basically, CGRAs on ASIC emphasize more on configuration capability to cover more applications, while FPGAs' inherent programmability greatly alleviate the concern. Accordingly, CGRAs on FPGA allow more intensive customization. 

The authors in \cite{kissler2006dynamically} developed WPPA a VLIW architecture based parameterizable CGRA overlay. There is an interconnection wrapper unit for each processing element (PE) and it can be used to dynamically configure the topology of the CGRA. The authors in \cite{ferreira2011fpga} proposed an heterogeneous CGRA overlay with multi-stage interconnection on FPGA and the compilation can be done in milliseconds, while the CGRA size is quite limited and the implementation frequency is low due to the multi-stage interconnection. In \cite{shukla2006quku}, QUKU a customized CGRA overlay was developed to improve reconfiguration speed of DSP algorithms. It can be used to bridge the gap between soft processor and customized IP core. The authors in \cite{capalijia2013pipelined} built a high speed mesh CGRA overlay using the elastic pipeline technique to achieve the maximum throughput. These CGRA overlays have demonstrated the promising performance acceleration capability for compute intensive applications. However, they mainly target the pure DFGs extracted from the compute kernels and it is insufficient for the FPGA accelerator design. In addition, the DFGs used are usually small and are limited to dozens of nodes to one or two hundred of nodes, while the benchmark in this work requires much larger DFGs.  

In this work, we opted to utilize a fully pipelined synchronous SCGRA as the overlay and had it implemented as an accelerator on Zedboard \cite{zedboard} which is a hybrid ARM + FPGA system. The overlay can be customized either for each application of the benchmark or the whole benchmark. Moreover, we presented an end-to-end run time evaluation of the benchmark. 

