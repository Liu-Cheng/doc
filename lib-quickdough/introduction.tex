\section{Introduction}\label{sec:introduction}
Recent years have witnessed a tremendous growth in the use of accelerators in computer systems to improve the systems' performance and energy efficiency \cite{kim2014compression, majumder2014hardware, iouliia2004reconfigurable, souradip2010hardware, putnam2014reconfigurable}. Among these accelerators, GPUs and Xeon Phi accelerators have stood out as two of the most popular choices in spite of their relatively short history as accelerators--5 of the top 10 systems on the top500 list take advantage of them \cite{top500}. On the other hand, despite the long and successful track record of FPGA accelerators with promising performance speedup and energy efficiency \cite{iouliia2004reconfigurable, souradip2010hardware, asano2009performance, che2008accelerating, thomas2009comparison}, the use of FPGA accelerators in main-stream systems remains limited and has yet to receive widespread adoption beyond highly skilled hardware engineers \cite{cong2011high}. When compared to the wide adoption of GPUs and Xeon Phi accelerators, it is believed that the much lower design productivity in developing FPGA applications, which is generally caused by both the lengthy FPGA implementation and notorious inaccessibility to software programmers, has become one of the major obstacles that hinder the software developers using FPGA as compute accelerators. 

In order to address the FPGA accessibility problem, recent advances in high level synthesis tools have significantly raised the abstraction level of FPGA design, allowing users to effectively express hardware designs using familiar software programming languages such as C/C++, Java, Python and Scala. However, despite the continuously evolved FPGA compilation algorithms and design methods in the past decades, the lengthy FPGA implementation process including synthesis, placing and routing which typically takes a few minutes for the smallest design and upwards to hours or even days for some of the largest design remains a major productivity hurdle to most software developers. 

The focus of this work is therefore to address this FPGA implementation challenge. In particular, we are interested in significantly improving the speed of generating FPGA accelerators for compute intensive loops expressed in high level languages while maintaining a competitive overall performance of the resulting FPGA accelerated computing system.

To that end, we have developed QuickDough, a design framework that rapidly generates loop accelerators and their associated software-hardware communication interfaces. By utilizing a soft coarse-grained reconfigurable array (SCGRA) overlay as an intermediate architecture implemented on top of the physical FPGA, we pre-build an accelerator library with a group of various configurations on top of the SCGRA overlay. With the pre-built library, QuickDough generates the loop accelerator by selecting an accelerator configuration from it, schedules the compute operations from the user-provided loop onto the accelerator, and finally updates the pre-built accelerator configuring the target FPGA, which essentially avoids the FPGA implementation process during the accelerator design iterations. By employing different configuration selection algorithms, QuickDough allows users to perform trade-off between performance and compilation time. At the end of the selection process, optimized communication interfaces will be produced accordingly. Meanwhile, QuickDough also helps the users to automatically pre-build an overlay based accelerator library targeting a single application or a group of similar applications. To expedite the library generation process, a small representative set of accelerator configurations are chosen as the library and generated automatically using a template based system.

In \secref{sec:framework}, the proposed FPGA acceleration design framework QuickDough including both the SCGRA overlay implementation and compilation will be elaborated. Then the automatic SCGRA overlay based accelerator library pre-building will be detailed in \secref{lib-build}. Experimental results are shown in \secref{sec:experiments}. Finally, we will discuss the limitations of current implementation in \secref{sec:discussion} and conclude in \secref{sec:conclusions}.
