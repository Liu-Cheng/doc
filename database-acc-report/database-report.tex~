%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Simple Sectioned Essay Template
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing essay content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article} % Default font size is 12pt, it can be changed here

\usepackage{geometry} % Required to change the page size to A4
\geometry{a4paper} % Set the page size to be A4 as opposed to the default US Letter

\usepackage{graphicx} % Required for including pictures

\usepackage{float} % Allows putting an [H] in \begin{figure} to specify the exact location of the figure
\usepackage{wrapfig} % Allows in-line images such as the example fish picture

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{url}

\linespread{1.2} % Line spacing

%\setlength\parindent{0pt} % Uncomment to remove all indentation from paragraphs

\graphicspath{{./figures/}} % Specifies the directory where pictures are stored

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

\HRule \\[0.4cm]
{ \huge \bfseries Database Query Acceleration with Reconfigurable Computing Fabrics}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

\begin{minipage}{0.4\textwidth}
    \centering {Cheng Liu} \\ 
    \vspace{2em}
    \centering {\large \today}
\end{minipage}

\end{titlepage}

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\tableofcontents % Include a table of contents

\newpage % Begins the essay on a new page instead of on the same page as the table of contents 

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------
\section{Motivation} % Major section
FPGAs have been used as accelerators for high performance relation database applications. Compared
to other parallel computing architectures such as multi-core processors and GPUs, FPGAs usually
outperform on energy efficiency and can also achieve comparable performance in many cases. The
use of FPGAs for database acceleration now has attracted increasing attentions of database researchers
from both academia and industry. 

Most of the previous work focus on building specific circuits for the typical
compute-intensive operations involved in database query applications using either hardware description languages
(HDLs) or high level synthesis (HLS) languages while leaving the hardware unchanged until the
applications are changed. This explores the use of FPGAs for specific hardware accelerator design
and will be good enough when the application doesn't change with time. However, there are many cases
that the required FPGA accelerators may change with time. 

For instances, the load of database query may change with time and different types of
operations are needed accordingly. On top of the system fluctuation, the same operation such as sort
operating on different attributes of the database which can be float, string, char or integer utilizes
diverse FPGA resources. Unlike general computing architectures (i.e. CPU and GPUs) which typically use the
same computing cores to handle all the different operations, FPGAs needs specific hardware for each
types of operations. Therefore, some of the operations implemented may only be used for a short period
of time while they may consume considerable hardware resources. In addition, some of the
combination of the operations may be more efficient than the separate implementations and the combined
implementations will be better when they are frequently used in the applications. But separate
implementations will be preferred when the operations are not used at the same time. The mismatch
between the database query and the underlying FPGA accelerators may result in severe performance and power
efficiency degradation. 

FPGAs which allows multiple granularities of reconfiguration using runtime mode selection, partial reconfiguration
techniques or multiple FPGA contexts can be adapted to bridge the gap and provide hardware accelerators as needed or just enough for the sake of performance and power efficiency of database query applications.

\section{Main Idea}
The basic database query processing system as shown in Fig. 1 follows the architecture that is used
in omniDB while the data-parallel
primitives will be implemented on FPGA. From the perspective of omniDB, the FPGA is abstracted as a
library providing all kinds of efficient data parallel primitives. Each primitive may have multiple
instances implemented on the FPGA. All the primitives implemented on FPGAs are managed by a
primitive resource manager. The manager will allocate a sequence of primitives to the high level data query
operators. When there are abundant hardware primitives, the manager will allocate hardware operators
as needed which essentially make best use of spacial resources providing the best performance. When
there are only limited hardware primitives, the manager will provide just enough primitives to high
level operators which try to temporally reuse the hardware resources.   

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{db-accelerator}
\caption{Database Processing Architecture Using FPGA Accelerators}
\label{fig:db-accelerator}
\end{figure}


To make best use of the hardware accelerators, a request queue will be maintained in the manager.
With the status of the queue, the underlying hardware primitives that will be needed can be analyzed
at runtime. Given this runtime information, the FPGAs can be reconfigured to match the requirements
at runtime using partial reconfigurations or some other dynamic reconfiguration techniques.
With some other high-level data query information, it is possible to reduce the frequency of the
runtime reconfiguration and thus are beneficial to the overall system. 

\subsection{Data query variation}


\subsection{How long does it take to reconfigure?}


\section{Summary} 
Taking advantage of the FPGA's reconfigurability, the FPGA accelerators can be dynamically
reshaped to provide more hotspot acceleration fabrics based on the runtime requirements of data
query, which are beneficial to both the system's performance and power efficiency.

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{refs}
%----------------------------------------------------------------------------------------

\end{document}
