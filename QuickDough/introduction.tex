\section{Introduction}\label{sec:introduction}

By raising the abstraction level of the physical FPGA hardware, numerous researchers have demonstrated the potential of utilizing FPGA overlay architectures as a way to improve designers' productivity\cite{Lebedev2010,kissler2006dynamically,unnikrishnan2009application,Yiannacouras2009FPS,Guy2012VENICE,Jeffrey2011potential}.
Overlay architectures, similar to overlay networks in conventional network designs, are intermediate virtual architectures that are overlaid on top of the physical FPGA configurable fabric with purposes such as to improve design portability, security, and designer's productivity.
Overlay architectures may be utilized at different stages of application implementation and have thus manifested in a number of different forms.
Examples of overlays developed for such purposes range from parametric HDL models, pre-synthesized or pre-implemented circuits, to multicore processors or even arrays of coarse-grained processing units connected by an on-chip network.
In practice, the additional overlay layer may in some cases result in implementations with less than optimal performance when compared to their hand-optimized alternatives.
Nevertheless, the use of overlays remain highly anticipated as many early works have already demonstrated their potential as techniques to improve portability, security, and most importantly, productivity of application designers using FPGA-based reconfigurable computers.

In this work, the QuickDough rapid compilation and synthesis framework for applications targeting hybrid CPU-FPGA systems is presented.  The goal of QuickDough is to provide a high-productivity compilation framework for applications that execute on both CPU and FPGA during run time.
In particular, it automates the process of generating hardware accelerators and their associated CPU-FPGA communication infrastructure for loop kernels that are designated for FPGA acceleration by the user.
By utilizing a soft coarse-grained reconfigurable array (SCGRA) as an overlay, QuickDough is able to generate the configuration bitstream for the targeted platform rapidly in the order of seconds.

QuickDough achieves this speed by first translating compute kernels into data flow graphs (DFGs), which are then statically scheduled onto the target overlay.
It then integrates the scheduling result with a pre-implemented bitstream of the overlay to produce the final configuration bitstream with both the accelerator and its communication infrastructure.

When compared to a typical FPGA implementation flow that includes lengthy steps such as synthesis and place-and-route, the run time of QuickDough is almost 2 orders of magnitude shorter when compiling our benchmark programs.
Although the implementation of the overlay must eventually rely on conventional hardware design tools, only one instance of the implementation is required per application or application domain throughout the design iterations.  The lengthy hardware implementation process can therefore be amortized as the number of compile-debug-edit cycle increases.

Most importantly, despite the introduction of an overlay, the end-to-end run time of our benchmark in the generated system is comparable to the accelerators that are generated by a typical HLS flow.
Furthermore, as the proposed overlay structure is very regular with short connections, the resulting implementation is highly scalable.
In our experiments, the size of the proposed overlay can easily be scaled without major impact on implementation frequency.
Our scheduler can also take advantage of the additional processing elements of larger overlays to improve execution time of most benchmark.
Currently, the key limitation to the array size is hardware overhead due to the additional memory requirement of the proposed processing element array.


After exploring related work in next section, the QuickDough design methodology will be elaborated in \secref{sec:framework}.  The design and implementation of the overlay will then be presented in \secref{sec:scgraimplement}  and the compilation framework will be illustrated in \secref{sec:scgracompile}.  In \secref{sec:experiments}, experimental results will be shown.  Finally, we will discuss the benefit and limitations of current implementation in \secref{sec:discussion} and conclude in \secref{sec:conclusions}.
